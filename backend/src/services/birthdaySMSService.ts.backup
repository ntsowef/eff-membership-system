import { executeQuery } from '../config/database';
import { SMSManagementService } from './smsManagementService';

// Create a simple logger if it doesn't exist
const logger = {
  info: (message: string, meta?: any) => console.log('[INFO]', message, meta || ''),
  error: (message: string, meta?: any) => console.error('[ERROR]', message, meta || ''),
  warn: (message: string, meta?: any) => console.warn('[WARN]', message, meta || ''),
  debug: (message: string, meta?: any) => console.debug('[DEBUG]', message, meta || '')
};

export interface BirthdayMember {
  member_id: number;
  full_name: string;
  firstname: string;
  surname: string;
  cell_number: string;
  date_of_birth: string;
  current_age: number;
  ward_code: string;
  ward_name?: string;
  municipality_code?: string;
}

export interface BirthdayConfig {
  id: number;
  is_enabled: boolean;
  template_id: number;
  send_time: string;
  timezone: string;
  include_age: boolean;
  include_organization_name: boolean;
  max_daily_sends: number;
}

export interface BirthdayQueueItem {
  id?: number;
  member_id: number;
  member_name: string;
  member_phone: string;
  birth_date: string;
  age_at_birthday: number;
  scheduled_for: string;
  template_id?: number;
  personalized_message?: string;
  status: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
}

export class BirthdaySMSService {
  
  // Get birthday configuration
  static async getBirthdayConfig(): Promise<BirthdayConfig | null> {
    try {
      // Return default config since birthday_sms_config table doesn't exist
      // Using birthday_message_templates table instead
      const result = await executeQuery(`
        SELECT
          id as template_id,
          TRUE as is_enabled,
          '09:00:00' as send_time,
          'Africa/Johannesburg' as timezone,
          TRUE as include_age,
          TRUE as include_organization_name,
          1000 as max_daily_sends
        FROM birthday_message_templates
        WHERE is_active = TRUE
        ORDER BY created_at DESC
        LIMIT 1
      `);

      const configs = Array.isArray(result) ? result : result[0] || [];
      if (configs.length > 0) {
        return {
          id: 1,
          is_enabled: true,
          template_id: configs[0].template_id,
          send_time: '09:00:00',
          timezone: 'Africa/Johannesburg',
          include_age: true,
          include_organization_name: true,
          max_daily_sends: 1000
        };
      }
      return null;
    } catch (error: any) {
      logger.error('Failed to get birthday config', { error: error.message });
      // Return default config on error
      return {
        id: 1,
        is_enabled: true,
        template_id: 1,
        send_time: '09:00:00',
        timezone: 'Africa/Johannesburg',
        include_age: true,
        include_organization_name: true,
        max_daily_sends: 1000
      };
    }
  }

  // Get today's birthdays
  static async getTodaysBirthdays(): Promise<BirthdayMember[]> {
    try {
      const result = await executeQuery(`
        SELECT
          member_id,
          CONCAT(first_name, ' ', last_name) as full_name,
          first_name as firstname,
          last_name as surname,
          phone_number as cell_number,
          date_of_birth,
          age as current_age,
          ward_code,
          ward_name,
          province_code
        FROM vw_todays_birthdays
        ORDER BY first_name, last_name
      `);
      return Array.isArray(result) ? result : result[0] || [];
    } catch (error: any) {
      logger.error('Failed to get today\'s birthdays', { error: error.message });
      throw error;
    }
  }

  // Get upcoming birthdays
  static async getUpcomingBirthdays(days: number = 7): Promise<BirthdayMember[]> {
    try {
      const result = await executeQuery(`
        SELECT
          member_id,
          CONCAT(first_name, ' ', last_name) as full_name,
          first_name as firstname,
          last_name as surname,
          phone_number as cell_number,
          date_of_birth,
          current_age,
          '' as ward_code,
          province_code,
          days_until_birthday
        FROM vw_upcoming_birthdays
        WHERE days_until_birthday <= $1
        ORDER BY days_until_birthday ASC, first_name ASC, last_name ASC
      `, [days]);

      return Array.isArray(result) ? result  : result[0] || [];
    } catch (error: any) {
      logger.error('Failed to get upcoming birthdays', { error: error.message });
      throw error;
    }
  }

  // Queue birthday messages for today
  static async queueTodaysBirthdayMessages(): Promise<{ queued: number; skipped: number; errors: number }> {
    try {
      const config = await this.getBirthdayConfig();
      if (!config || !config.is_enabled) {
        logger.warn('Birthday SMS is disabled or not configured');
        return { queued: 0, skipped: 0, errors: 0 };
      }

      const todaysBirthdays = await this.getTodaysBirthdays();
      let queued = 0;
      let skipped = 0;
      let errors = 0;

      for (const member of todaysBirthdays) {
        try {
          // Check if already sent today
          const existingResult = await executeQuery(`
            SELECT id FROM birthday_messages_sent
            WHERE member_id = $1 AND DATE(sent_at) = CURRENT_DATE
          `, [member.member_id]);

          const existing = Array.isArray(existingResult) ? existingResult  : existingResult[0] || [];
          if (existing.length > 0) {
            skipped++;
            continue;
          }

          // Generate personalized message
          const personalizedMessage = await this.generateBirthdayMessage(member, config);

          // Send the message directly (no queue needed for birthday messages)
          const result = await this.sendBirthdayMessage(member.member_id, personalizedMessage);

          if (result.success) {
            queued++;
            logger.info('Sent birthday message to ' + member.full_name + '');
          } else {
            errors++;
            logger.error('Failed to send birthday message to ' + member.full_name + '', { error: result.error });
          }

        } catch (error : any) {
          logger.error('Failed to queue birthday message for member ' + member.member_id + '', { error: error.message });
          errors++;
        }
      }

      logger.info(`Birthday message queueing complete`, { queued, skipped, errors });
      return { queued, skipped, errors };

    } catch (error: any) {
      logger.error('Failed to queue birthday messages', { error: error.message });
      throw error;
    }
  }

  // Generate personalized birthday message
  static async generateBirthdayMessage(member: BirthdayMember, config: BirthdayConfig): Promise<string> {
    try {
      // Get the template
      const template = await SMSManagementService.getTemplateById(config.template_id);
      if (!template) {
        throw new Error('Birthday template not found: ' + config.template_id + '');
      }

      let message = template.content;

      // Replace variables
      const variables = {
        name: member.firstname,
        full_name: member.full_name,
        age: config.include_age ? member.current_age.toString() : '',
        organization: config.include_organization_name ? 'Our Organization'  : '',
        ward: member.ward_name || 'Ward ' + member.ward_code + '',
        municipality: member.municipality_code || '',
        ward_code: member.ward_code
      };

      // Process variables
      Object.keys(variables).forEach(key => {
        const placeholder = '{' + key + '}';
        message = message.replace(new RegExp(placeholder, 'g'), variables[key as keyof typeof variables] || '');
      });

      return message;

    } catch (error: any) {
      logger.error('Failed to generate birthday message', { error: error.message, member });
      throw error;
    }
  }

  // Process queued birthday messages (deprecated - now sending directly)
  static async processQueuedMessages(limit: number = 50): Promise<{ processed: number; sent: number; failed: number }> {
    try {
      logger.info('processQueuedMessages is deprecated - birthday messages are now sent directly');
      return { processed: 0, sent: 0, failed: 0 };
    } catch (error : any) {
      logger.error('Failed to process queued birthday messages', { error: error.message });
      throw error;
    }
  }

  // Deprecated queue processing code - keeping structure for reference
  private static async _oldProcessQueuedMessages(limit: number = 50): Promise<{ processed: number; sent: number; failed: number }> {
    try {
      const config = await this.getBirthdayConfig();
      if (!config || !config.is_enabled) {
        return { processed: 0, sent: 0, failed: 0 };
      }

      // Old queue processing code removed - now sending directly
      return { processed: 0, sent: 0, failed: 0 };
    } catch (error : any) {
      logger.error('Failed to process queued birthday messages', { error: error.message });
      throw error;
    }
  }

  // Get birthday statistics
  static async getBirthdayStatistics(): Promise<any> {
    try {
      const todayResult = await executeQuery('SELECT COUNT(*) as count FROM vw_todays_birthdays');
      const upcomingResult = await executeQuery('SELECT COUNT(*) as count FROM vw_upcoming_birthdays WHERE days_until_birthday <= 7');
      const queuedResult = await executeQuery(`SELECT COUNT(*) as count FROM sms_queue WHERE status = 'Pending'`);
      const sentTodayResult = await executeQuery(`
        SELECT COUNT(*) as count FROM birthday_messages_sent
        WHERE DATE(sent_at) = CURRENT_DATE AND delivery_status = 'delivered'
      `);

      const today = Array.isArray(todayResult) ? todayResult : todayResult[0] || [];
      const upcoming = Array.isArray(upcomingResult) ? upcomingResult : upcomingResult[0] || [];
      const queued = Array.isArray(queuedResult) ? queuedResult : queuedResult[0] || [];
      const sentToday = Array.isArray(sentTodayResult) ? sentTodayResult : sentTodayResult[0] || [];

      return {
        todays_birthdays: today[0]?.count || 0,
        upcoming_birthdays: upcoming[0]?.count || 0,
        queued_messages: queued[0]?.count || 0,
        sent_today: sentToday[0]?.count || 0
      };

    } catch (error: any) {
      logger.error('Failed to get birthday statistics', { error: error.message });
      throw error;
    }
  }

  // Manual birthday message sending
  static async sendBirthdayMessage(memberId: number, customMessage?: string): Promise<{ success: boolean; message?: string; error?: string; messageId?: string }> {
    try {
      const config = await this.getBirthdayConfig();
      if (!config || !config.is_enabled) {
        return { success: false, error: 'Birthday SMS is disabled or not configured' };
      }

      // Get member details
      const memberResult = await executeQuery(`
        SELECT
          m.member_id,
          m.membership_number,
          CONCAT(m.firstname, ' ', COALESCE(m.surname, '')) as full_name,
          m.firstname,
          m.surname,
          m.cell_number,
          m.date_of_birth,
          EXTRACT(YEAR FROM AGE(m.date_of_birth)) as current_age,
          m.ward_code,
          w.ward_name,
          w.municipality_code
        FROM members m
        LEFT JOIN wards w ON m.ward_code = w.ward_code
        WHERE m.member_id = $1 AND m.cell_number IS NOT NULL AND m.cell_number != ''
      `, [memberId]);

      const members = Array.isArray(memberResult) ? memberResult  : memberResult[0] || [];
      if (members.length === 0) {
        return { success: false, error: 'Member not found or no phone number' };
      }

      const member = members[0];

      // Generate personalized message or use custom message
      const personalizedMessage = customMessage || await this.generateBirthdayMessage(member, config);

      // Send the SMS
      const smsResult = await SMSManagementService.sendSMSMessage({
        recipient_phone: member.cell_number,
        recipient_name: member.full_name,
        recipient_member_id: member.member_id,
        message_content: personalizedMessage,
        status: 'pending',
        retry_count: 0,
        cost_per_sms: 0.05,
        total_cost: 0.05
      });

      if (smsResult.success) {
        // Record in birthday_messages_sent table
        const currentYear = new Date().getFullYear();
        await executeQuery(`
          INSERT INTO birthday_messages_sent (
            member_id, membership_number, member_name, phone_number, message_text,
            sms_message_id, delivery_status, birthday_year, member_age
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, [
          member.member_id,
          member.membership_number || '',
          member.full_name,
          member.cell_number,
          personalizedMessage,
          smsResult.messageId || '',
          'delivered',
          currentYear,
          member.current_age
        ]);

        return {
          success : true,
          message: 'Birthday SMS sent to ' + member.full_name + '',
          messageId: smsResult.messageId
        };
      } else {
        return { success: false, error: smsResult.error || 'Failed to send SMS' };
      }

    } catch (error: any) {
      logger.error('Failed to send manual birthday message', { error: error.message, memberId });
      return { success: false, error: error.message };
    }
  }
}

export default BirthdaySMSService;
