import { executeQuery } from '../config/database';
import axios from 'axios';

// Create a simple logger if it doesn't exist
const logger = {
  info: (message: string, meta$1: any) => console.log('[INFO] ' + message + '', meta || ''),
  error: (message: string, meta$1: any) => console.error('[ERROR] ' + message + '', meta || ''),
  warn: (message: string, meta$1: any) => console.warn('[WARN] ' + message + '', meta || ''),
  debug: (message: string, meta$1: any) => console.debug('[DEBUG] ' + message + '', meta || '')
};

export interface SMSTemplate {
  id?: number;
  name: string;
  description?: string;
  content: string;
  variables: string[];
  category: 'campaign' | 'notification' | 'reminder' | 'announcement' | 'custom';
  is_active: boolean;
  created_by?: number;
}

export interface SMSCampaign {
  id?: number;
  name: string;
  description?: string;
  template_id?: number;
  message_content: string;
  target_type: 'all' | 'province' | 'district' | 'municipality' | 'ward' | 'custom' | 'list';
  target_criteria: any;
  status: 'draft' | 'scheduled' | 'sending' | 'sent' | 'paused' | 'cancelled' | 'failed';
  scheduled_at?: Date | null;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  send_rate_limit: number;
  retry_failed: boolean;
  max_retries: number;
  created_by?: number;
}

export interface SMSMessage {
  id?: number;
  campaign_id?: number;
  recipient_phone: string;
  recipient_name?: string;
  recipient_member_id?: number;
  message_content: string;
  status: 'pending' | 'queued' | 'sending' | 'sent' | 'delivered' | 'failed' | 'expired';
  provider_message_id?: string;
  error_code?: string;
  error_message?: string;
  retry_count: number;
  cost_per_sms: number;
  total_cost: number;
}

export interface SMSContactList {
  id?: number;
  name: string;
  description?: string;
  total_contacts: number;
  active_contacts: number;
  is_active: boolean;
  allow_duplicates: boolean;
  created_by?: number;
}

export class SMSManagementService {
  // Template Management
  static async createTemplate(template: SMSTemplate): Promise<number> {
    try {
      const result = await executeQuery(`
        INSERT INTO sms_templates (name, description, content, variables, category, is_active, created_by)
        EXCLUDED.?, ?, ?, ?, ?, ?, ?
      `, [
        template.name,
        template.description,
        template.content,
        JSON.stringify(template.variables),
        template.category,
        template.is_active,
        template.created_by
      ]);

      const insertResult = Array.isArray(result) ? result[0] : result;
      logger.info('SMS template created: ' + template.name + '', { templateId: insertResult.insertId });
      return insertResult.insertId;
    } catch (error: any) {
      logger.error('Failed to create SMS template', { error: error.message, template });
      throw error;
    }
  }

  static async getTemplates(filters: {
    category?: string;
    is_active?: boolean;
    search?: string;
  } = {}): Promise<SMSTemplate[]> {
    try {
      let query = 'SELECT * FROM sms_templates WHERE 1= TRUE';
      const params: any[] = [];

      if (filters.category) {
        query += ' AND category = ? ';
        params.push(filters.category);
      }

      if (filters.is_active !== undefined) {
        query += ' AND is_active = $1';
        params.push(filters.is_active);
      }

      if (filters.search) {
        query += ' AND (name LIKE ? OR description LIKE  OR content LIKE $3)';
        const searchTerm = '%' + filters.search + '%';
        params.push(searchTerm, searchTerm, searchTerm);
      }

      query += ' ORDER BY created_at DESC';

      const result = await executeQuery(query, params);
      const templates = Array.isArray(result) ? result   : result[0] || [];

      return templates.map((template: any) => ({
        ...template,
        variables: JSON.parse(template.variables || '[]')
      }));
    } catch (error: any) {
      logger.error('Failed to get SMS templates', { error: error.message, filters });
      throw error;
    }
  }

  static async getTemplateById(id: number): Promise<SMSTemplate | null> {
    try {
      const result = await executeQuery(
        'SELECT * FROM sms_templates WHERE id = ? ',
        [id]
      );

      const templates = Array.isArray(result) ? result  : result[0] || [];
      if (templates.length === 0) return null;

      const template = templates[0];
      return {
        ...template,
        variables: JSON.parse(template.variables || '[]')
      };
    } catch (error: any) {
      logger.error('Failed to get SMS template by ID', { error: error.message, id });
      throw error;
    }
  }

  static async updateTemplate(id: number, updates: Partial<SMSTemplate>): Promise<boolean> {
    try {
      const setClause: string[] = [];
      const params: any[] = [];

      if (updates.name !== undefined) {
        setClause.push('name = ? ');
        params.push(updates.name);
      }
      if (updates.description !== undefined) {
        setClause.push('description = $1');
        params.push(updates.description);
      }
      if (updates.content !== undefined) {
        setClause.push('content = $1');
        params.push(updates.content);
      }
      if (updates.variables !== undefined) {
        setClause.push('variables = $1');
        params.push(JSON.stringify(updates.variables));
      }
      if (updates.category !== undefined) {
        setClause.push('category = $1');
        params.push(updates.category);
      }
      if (updates.is_active !== undefined) {
        setClause.push('is_active = $1');
        params.push(updates.is_active);
      }

      if (setClause.length === 0) return false;

      params.push(id);

      const updateResult = await executeQuery('
        UPDATE sms_templates
        SET ' + setClause.join(', ') + ', updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      ', params);

      const result = Array.isArray(updateResult) ? updateResult[0]  : updateResult;
      logger.info('SMS template updated: ' + id + '', { affectedRows: result.affectedRows });
      return result.affectedRows > 0;
    } catch (error: any) {
      logger.error('Failed to update SMS template', { error: error.message, id, updates });
      throw error;
    }
  }

  static async deleteTemplate(id: number): Promise<boolean> {
    try {
      const deleteResult = await executeQuery(
        'DELETE FROM sms_templates WHERE id = ? ',
        [id]
      );

      const result = Array.isArray(deleteResult) ? deleteResult[0]  : deleteResult;
      logger.info('SMS template deleted: ' + id + '', { affectedRows: result.affectedRows });
      return result.affectedRows > 0;
    } catch (error: any) {
      logger.error('Failed to delete SMS template', { error: error.message, id });
      throw error;
    }
  }

  // Campaign Management
  static async createCampaign(campaign: SMSCampaign): Promise<number> {
    try {
      const createResult = await executeQuery(`
        INSERT INTO sms_campaigns (
          name, description, template_id, message_content, target_type, target_criteria,
          status, scheduled_at, priority, send_rate_limit, retry_failed, max_retries, created_by
        ) EXCLUDED.?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
      `, [
        campaign.name,
        campaign.description || null,
        campaign.template_id || null,
        campaign.message_content,
        campaign.target_type,
        JSON.stringify(campaign.target_criteria || {}),
        campaign.status,
        campaign.scheduled_at || null,
        campaign.priority,
        campaign.send_rate_limit,
        campaign.retry_failed,
        campaign.max_retries,
        campaign.created_by || null
      ]);

      const result = Array.isArray(createResult) ? createResult[0] : createResult;
      logger.info('SMS campaign created: ' + campaign.name + '', { campaignId: result.insertId });
      return result.insertId;
    } catch (error: any) {
      logger.error('Failed to create SMS campaign', { error: error.message, campaign });
      throw error;
    }
  }

  static async getCampaigns(filters: {
    status?: string;
    target_type?: string;
    created_by?: number;
    search?: string;
    page?: number;
    limit?: number;
  } = {}): Promise<{ campaigns: SMSCampaign[]; total: number; pagination: any }> {
    try {
      const page = filters.page || 1;
      const limit = filters.limit || 20;
      const offset = (page - 1) * limit;

      let whereClause = 'WHERE 1= TRUE';
      const params: any[] = [];

      if (filters.status) {
        whereClause += ' AND status = ? ';
        params.push(filters.status);
      }

      if (filters.target_type) {
        whereClause += ' AND target_type = $1';
        params.push(filters.target_type);
      }

      if (filters.created_by) {
        whereClause += ' AND created_by = $1';
        params.push(filters.created_by);
      }

      if (filters.search) {
        whereClause += ' AND (name LIKE ? OR description LIKE )';
        const searchTerm = '%' + filters.search + '%';
        params.push(searchTerm, searchTerm);
      }

      // Get total count
      const countResultData = await executeQuery('
        SELECT COUNT(*) as total FROM sms_campaigns ' + whereClause + ' + ', params);

      const countResult = Array.isArray(countResultData) ? countResultData   : countResultData[0] || [];
      const total = countResult[0]?.total || 0;

      // Get campaigns
      const campaignsResultData = await executeQuery('
        SELECT c.*, t.name as template_name
        FROM sms_campaigns c
        LEFT JOIN sms_templates t ON c.template_id = t.id
        ' + whereClause + '
        ORDER BY c.created_at DESC
        LIMIT ? OFFSET ?
      ', [...params, limit, offset]);

      const campaigns = Array.isArray(campaignsResultData) ? campaignsResultData : campaignsResultData[0] || [];
      const processedCampaigns = campaigns.map((campaign: any) => ({
        ...campaign,
        target_criteria: JSON.parse(campaign.target_criteria || '{}')
      }));

      return {
        campaigns: processedCampaigns,
        total,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      };
    } catch (error: any) {
      logger.error('Failed to get SMS campaigns', { error: error.message, filters });
      throw error;
    }
  }

  static async getCampaignById(id: number): Promise<SMSCampaign | null> {
    try {
      const campaignsResultData = await executeQuery(`
        SELECT c.*, t.name as template_name
        FROM sms_campaigns c
        LEFT JOIN sms_templates t ON c.template_id = t.id
        WHERE c.id = ? `, [id]);

      const campaigns = Array.isArray(campaignsResultData) ? campaignsResultData  : campaignsResultData[0] || [];
      if (campaigns.length === 0) return null;

      const campaign = campaigns[0];
      return {
        ...campaign,
        target_criteria: JSON.parse(campaign.target_criteria || '{}')
      };
    } catch (error: any) {
      logger.error('Failed to get SMS campaign by ID', { error: error.message, id });
      throw error;
    }
  }

  // Message Processing
  static async processMessageVariables(content: string, variables: any): Promise<string> {
    let processedContent = content;
    
    Object.keys(variables).forEach(key => {
      const placeholder = '{' + key + '}';
      processedContent = processedContent.replace(new RegExp(placeholder, 'g'), variables[key] || '');
    });

    return processedContent;
  }

  static async calculateSMSParts(content: string): Promise<number> {
    // Basic SMS part calculation (160 chars for GSM, 70 for Unicode)
    const hasUnicode = /[^\x00-\x7F]/.test(content);
    const maxLength = hasUnicode ? 70 : 160;
    return Math.ceil(content.length / maxLength);
  }

  static async getCampaignStatistics(campaignId: number): Promise<any> {
    try {
      const statsResultData = await executeQuery(`
        SELECT
          COUNT(*) as total_messages,
          SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_count,
          SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered_count,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_count,
          SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_count,
          SUM(total_cost) as total_cost,
          AVG(sms_parts) as avg_sms_parts
        FROM sms_messages
        WHERE campaign_id = ? `, [campaignId]);

      const stats = Array.isArray(statsResultData) ? statsResultData  : statsResultData[0] || [];
      return stats[0] || {
        total_messages: 0,
        sent_count: 0,
        delivered_count: 0,
        failed_count: 0,
        pending_count: 0,
        total_cost: 0,
        avg_sms_parts: 0
      };
    } catch (error: any) {
      logger.error('Failed to get campaign statistics', { error: error.message, campaignId });
      throw error;
    }
  }

  // Mock SMS sending for development
  static async sendSMSMessage(message: SMSMessage): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      // Mock SMS sending - in production, integrate with real SMS provider
      const messageId = 'mock_${Date.now()}_' + Math.random().toString(36).substr(2, 9) + '';
      
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Mock success/failure (90% success rate)
      const success = Math.random() > 0.1;
      
      if (success) {
        logger.info(`Mock SMS sent successfully`, { 
          phone: message.recipient_phone, 
          messageId,
          content: message.message_content.substring(0, 50) + '...'
        });
        
        return { success: true, messageId };
      } else {
        const error = 'Mock SMS delivery failed';
        logger.error(`Mock SMS failed`, { 
          phone: message.recipient_phone, 
          error,
          content: message.message_content.substring(0, 50) + '...'
        });
        
        return { success: false, error };
      }
    } catch (error: any) {
      logger.error('Failed to send SMS message', { error: error.message, message });
      return { success: false, error: error.message };
    }
  }
}

export default SMSManagementService;
